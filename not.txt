*plus buton done
*plus buton ile flatlistin ust uste gelmesi done
*react redux ile notları pushlama ve flatliste verme done
*flatlist ile notecard componentini kullanarak notları listeleme done
*mevcut notları yeni bi sayfada goruntuleme done
*mevcut notları reduxa yazılan fonksiyon ile update etme done
********************************************

*notları silinmesi (push ve update tamam) done  
*notları localstorage'a kaydetme  done 
*notların kaydırılarak update ve delete işlemleri done
******************************************************

*notların listelenme biçim değişiklikleri - renk done
*not editlenince ve eklenemeyince flash message done
*zaman muhabbeti done
*notun ilk satırını gösterme done
*not sabitleme //isPinned=false ekledik done
*toplu mesaj silme done
//burda kaldık reduxa ekledik ama mantıksız oluyor kapatıp açtığında saçma olur sadece state'de kalması daha mantıklı bu işi notebook'da çözmeliyik 
-- bu işi state'den çözelim reduxtan değil, redux persist işimizi kolaylaştırdı ama redux'a hakimiyetimizi kaybetttik
ikinci bi slice denenebilir yeni store yeni Provider
//  configdeki whitelist notes state ismi degil reducer ismi, yeni bi slice ekledik ve cozum bulduk

*alttaki şeyler bir hamburger menü ile yani yandan açılan kısım ile verilsin hatta toplu mesaj seç bile oraya eklebilir done
*gece gündüz modu done
*notların listelenme biçim değişiklikleri - düzen pakette yok yapmadık
-search done
-notların renk değişiklikleri seçenekleri done

-share button done
-drawer'e tarihe göre sıralama vs ekleme ile açılır menü ekleme (accordion menu) done
-bildirim onesignal ile done gibi
-nota longPress basınca yeni menu çıkarma done sadece share kaldı
-share'i bitir done
-long press açılınca arkası blurlansın done
-once en yeni once en yakın ikiye bölünmüş telefonda ui kaymış done
-arama kısmı üste alta kayıyor done

-notları seç hiçbişey seçmeyince yine sildi
-reanimated paketi ile uygulamaya animasyon ekleme (plus butonunun kaybolması bulk selectedsa mesajın kayması vs)

+ geçmiş notlardaki night mode bugunu code push ile at / not yazmadaki scrollenabled muhabbetini dene ona göre sil ve codepushla gönder

++++BUG not kaydırma ile iş bitince kapansın / pinleme de index değiştiği için sorun çıktı doc da başkasına tıklanınca diğerinin kapanmasnı anlamadık ? https://snack.expo.dev/@jemise111/react-native-swipe-list-view
++++BUG toplu silmede tüm mesaja tıklayınca icon'un çalışması
++++BUG uygulama resmi yok canlıda
++++BUG kaydet boşluk olunca da çalışıyo
++++BUG toplu silmede hiç bişey seçili değilse de silinebiliyor
-BUG Search de işlem yapılınca search silinmiyo ama bütün hepsi geliyor

-CODEREVIEW table yada list goruntulenmesini notebooktan yaparken farklı bir component'ten çağırır gibi yapınca notları seç çalışmadı 
ama direkt return'un içinde çalıştırınca çalıştı ama return un içi çok dolu oldu?



      //video
      https://www.youtube.com/watch?v=oEc6ndf8MXg&list=PLaAoUJDWH9WonhD-ZLyYber1O7LnoI62w&index=1&ab_channel=FullStackNiraj
      --------------------------------
      *colorları dosyadan alma = color.js diye dosyanın içine export default {DARK: '#232323' , PRIMARY: '#1f1f1f' , ERROR:...} vs yazıp style'ların içinde color=colors.PRIMARY
     --------------------------------
      *StatusBar = telefonun üstündeki saat şarj vs kısımla ilgili işlemler = StatusBar componenti
      --------------------------------
      *prop'a default değer => mesela bir componente (ör: vectorIcons'dan bir Icon) oluştururken <Icon size={size || 24} color={color || colors.DARK} />
      --------------------------------
      *fn+f2 = toplu variable name'ini değiştirme, toplu aynı kelimeleri seçip aynı değişikleri (taşıma,silme ekleme vs) yapma = ctrl + d
      --------------------------------
      *saate göre günaydın iyi akşamlar yazdırabilme = new Date().getHours()    =>>> 21 17 06 vs dondurur günaydın iyi akşamlar mesajı böyle halledilir
      --------------------------------
      * componente style verme ve çağırıldığı yerdende ekstra stil ekleyebilme:

      const roundIconBtn = ({name,size,color,style}) => {
        return (
          size = {size || 24}
          ....
          style = { [ styles.icon, {...style} ] }
        )
      }

      const styles = StyleSheet.create({
        icon: {
          ........
        }
      })
      --------------------------------
      * StyleSheet.absoluteFillObject => bunu bir style içine vermemiz o comp'un tam olarak ortalamnmasını sağlar diğer parent compları yok sayarak (pos:abs,top,left,bottom=0)
          kullanımı ise: <View style={[StyleSheet.absoluteFillObject , styles.headerContainer]} (video2 15.30)
      --------------------------------
      *Klavye dışına tıklanınca kapanma muabbeti = Not yazarken boş kısma tıkladığında klavyenin kapanmasını istiyordu bu yüzden en alta toucahblewithoutfeedback i çağırıp içine view verdi 
          verdiği View'in style özelliklerine Styles.absoluteFillObject ve flex:1 verdi tüm ekranı kapaması için ve onPress'ine de Keyboard.dismiss() fonk'u çağırdı
      --------------------------------
      * (bu modal olduğu için olabilir) başka state'i prop olarak başka yerden alma = custom component'de (modal) onSubmit propunda o component'in state değerlerini gonderdi onSubmit(title,desc) ile ve modalı cagırdı comp'da (noteScreen) 
           o comp'u çağırdığında title ve desc'e erişebildi.      <Modal onSubmit={handleSubmit} ....  function handleSubmit(title,desc) {console.log(title , desc)}   (3.video sonları)
      --------------------------------
      *title.trim() = normalde textInput da title state'i boş mu diye kontrol ederken if(!title) gibi kullanılır. ama sadece boşluk bırakılırsa string var sanır
         bunu engellemek için if(!title.trim()) kullanılabilir
      --------------------------------
      * uzun textlerde .... eklemek  =>      <Text numberOfLines ={2}> {text} </Text>    text iki satırı geçerse .... yazar
      --------------------------------
      * flatlistleri sütun mantığı verebilmek =  <Flatlist ... numColumns = {2} .. />  iki satıra böle böle yazdı
           ve numColumns > 1 ise  columnWrapperStyle verilebilir ={{justifyContent:'space-between'}}    ( 4 / 14.54)
      --------------------------------------------------------------------------------------------
      *  notları asyncStorage kaydetme mantığı: 
      NoteInputModal componenti title ve desc'i onSubmit propundan gönderdi ve NoteScreen içinden bu comp cagırıldı 
      ve text,desc değerleri NoteInputModal'dan handleOnSubmit metodu ile elde edildi

        const [notes,setNotes] = useState([])

        const findNotes = async () => {
          const result = await AsyncStorage.getItem('notes')
          if(result !== null) setNotes(JSON.parse(notes))
        }

        useEffect(() => {
          findNotes()
        }, [])
       
        const handleOnSubmit = async (title, desc) => {
            const note = { id: Date.now(), title, desc, time: Date.now() };
            const updatedNotes = [...notes, note];
            setNotes(updatedNotes);
            await AsyncStorage.setItem('notes', JSON.stringify(updatedNotes));
         };

         return (
          ....
            <NoteInputModal 
            visible={modalIsVisible} 
            onClose{()=> setModalVisible(false)}
            onSubmit={handleOnSubmit}
         )


         burada yapılan şey:
         1- yazılan son notu handleOnSubmit ile alıyoruz
         2- handleOnSubmit içinde const updatedNotes updatedNotes = [...notes, note] diyerek eski notları da alıp sonuncuyu ekliyoruz
         3- updatesNote'u notes state'inin son hali yapıyoruz
         4- updatesNote'u asyncStorage ile set ediyoruz
         5- useEffect içinde findNotes'u çağırıyoruz
         6- findNotes AsyncStorage ile get yapıp notes i alıyor ve setNotes() ile state'i güncelliyor
         7- notes state'ini flatlist ile kullanıyoruz

  ------------------------------------------------------------------------------------------------------------------------
    * Flatlist yatay yapma =>  numColumns={3} diyip flatlist'i yatay sütünsal mantıkla kullanabilmek için keyExtractor'a id den sonra toString() verdik ve bug gitti (ColorPaletteComponent.js) (4.video, 13.11)
      --------------------------------
    * flatlist arasına seperator koyma =  <FlatList .. ItemSeparatorComponent={renderSeperator} />      const renderSeperator = () => <View style={styles.seperator} />
      --------------------------------

    * navigationlarda gördüğümüz {...props} muhabbeti =>  navigationlarda componente prop vericeksek ...props demeliyiiz
      <Stack.Screen component={renderNote} name='Note'/> 

      const renderNote = (props) => <Note {...props} user={user} />
      --------------------------------
    * navigation header transparant => <Stack.Navigator screenOptions ={{headerTitle:'' , headerTransparent:true}}
      bu şekilde  header trasnparent oldu ve back butonu özelliği kaybolmadı veya kullanmak istediğimiz başka bir şey 
      --------------------------------
    * navigation useHeaderHeight => 

      yukardaki özelliği kullandığımızda paddingTop vermek zorundayız çünkü header ve component üst üste geliyor
      burda import {useHeaderHeight} from '@react-navigation/stack'
      const headerHeight = useHeaderHeight()
      paddingTop: headerHeight
      --------------------------------
    * navigationlarda obje değerlerini daha temiz gönderip almak =>
      gönderirken tek tek note'un değerlerini göndermek yerine note'u gönder ve
      tek tek şu hareketi yapcağımıza:
        const note = route.params.note
        const id = route.params.id
        const isPinned = route.params.isPinned
        
    şu daha mantıklı olabilir:
      const {note} = route.params
      sonra compenentler içinde kullan == <Text>{note.title}</Text>
      
      --------------------------------
    * time format işlemleri
        time: Date.now() olarak time değerini kaydetti
        ve time'ı yazdırırken şöyle formatladı:
    
     <Text style={styles.time}>`Created At ${formatDate(note.time)}`</Text>

      const formatDate = ms => {
        const date = new Date(ms);
        const day = date.getDate();
        const month = date.getMonth() + 1;
        const year = date.getFullYear();
        const hrs = date.getHours();
        const min = date.getMinutes();
        const sec = date.getSeconds();

        return `${day}/${month}/${year} - ${hrs}:${min}:${sec}`;   //12.02.2021 - 10.23.15
};